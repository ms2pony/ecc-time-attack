## 大数的表示形式

首先讲讲使用该目录代码需要的基础认知

大数在内存中存储，有两种存储形式，字符串(str)和二进制(bin)

### prerequirement

字节序，它是 cpu 架构规定的，有大端序和小端序，规定多字节对象中字节的排列顺序，单位是字节。
这个规定是对常规数据进行约束，而对其他自定义的数据并不影响，
也就是说 cpu 的一些操作，比如指令`add`和`sub`操作的数据就是常规数据，有 32-bit 的，也有 64-bit 的；
不常规的数据，我们对它们的操作往往要自己定义，所以字节序的作用在此时就没什么意义了

举个例子，你的电脑是 x86 的，它是小端序，
所以它的`add`，`sub`等指令在处理数据时就将多字节的数(64bit 的数等)的存储在内存中的数据以小端序的方式解释，
比如 2 个`short`类型的数 a,b 的在内存中的数据分别为`0x32 0x52`，`0x75 0x98`(按地址递增的顺序给出)，
x86 cpu 在用`add`操作 a,b 时应该会解释为`addw a(0x5232) b(0x9875)`，而不会是`addw a(0x3252) b(0x7598)`

再举一个例子，你使用`printf("%d",a)`打印一个 4 字节的 int 类型的数，在这个过程中 x86 将这个数的存储方式当成小端序，此时
你用某种手段，将存储该数地址的 4 个字节的数据倒序即将它们改成大端序，那么`printf("%d",a)`还是会将这个变量
看做是小端序，并不会因为你将地址的数据改成大端序而保持变量的原来的值打印，结果就是该变量打印值发生改变。

### 二进制存储

存储方式(字节序中的大端小端，连续和非连续存储，字序(word 序))，组织方式会影响存储数据，

二进制存储可以由以下几种方式实现：

1. 字节序

   - 大端序
     由于 x86 规定的字节序的小端序，如果大数的字节序硬是大端序，
     那么使用`add`指令或`printf`函数得到的结果就不会是预期的结果

   - 小端序

2. 数组
   这里将存放大数的数组的每个元素称为 limb

   - limb 大端序，limb 为 1 个字节

     例子：本项目就实现了这样一种大数存储，它是`uint8_t`类型的数组,
     且该数组的第一个字节表示该大数最高 2 位(16 进制，16 为底)，limb 为 1 字节时其实与字节序中的大端序一样

   - 小端，limb 为 1 个字节

     该数组的第一个字节表示该大数最低的 2 位(16 进制，16 为底)

3. 其他数据结构

### 字符串存储

表现形式，存储方式(大端小端，连续和非连续存储)，组织方式(这个一般不考虑)会影响存储数据

存储的是特定字符串形式的 ASCII 码，字符串的存储形式对于大数的值来说是大端模式，
即下标从 0 到结束依次记录的是大数从高位到低位的数的字符串

比如一个大数 a=`0x65ab433ac20b677ec66904893e4febb9c41ef0`,则该大数的字符串存储需要 40 个字节，有两个字节存储"0x"，
也就是 16 进制前缀，该大数大小为 152-bit，二进制存储仅需要 19 字节的空间，但字符串存储却远远高于这个数字。

除此之外一个相同的大数的字符串存储空间随着其字符串的形式的改变而改变，而二进制存储一般是一成不变的，
下面介绍几种字符串存储的形式：

1. 16 进制，此形式下，1 字节的数(如"ab")需要 2 字节存储，存储的是该数的 16 进制下的 ASCII 码，
   且往往要额外消耗 2 个字节来存放 16 进制前缀"0x"
2. 10 进制，最常见的形式，该形式 1 个字节的数需要 3 字节存储，因为 1 个字节所能表示的最大的数为`256`，该数为 3 位数，
   但是 2 个字节的数只需要 5 字节存储(2 字节最大的数为 65536，只有 5 位)，存储空间的增长并不是均匀，这与 16 进制不同

不考虑组织方式的话，这种存储方式一般在 c 语言中就是用 char 类型的数组来存储该形式的大数，
若是考虑组织方式的话可能就会用其他数据结构表示(但一般不考虑)。

## 数据编码存储

## 大数的显示方式

大数的显示会受 cpu 架构规定的字节序的影响，结果会造成显示的结果很难懂，解决的方法是重新实现针对该大数特定的一种显示方式的显示功能

### 进制

进制不同大数的显示方式不同，这个显而易见

### 正常显示

一般把最常见的显示形式称为正常显示，这种显示形式是最容易理解的

### 字符串存储的分段显示

1. 从高到底分段显示
   例子：`0x65ab433ac`，分 3 段，每段 2 字节，显示结果为：`0x0006 0x5ab4 0x33ac`

2. 从低到高分段显示
   例子：`0x65ab433ac`，分 3 段，每段 2 字节，显示结果为：`0x33ac 0x5ab4 0x0006`

3. 从高到底分段显示-不加前缀
   例子：`0x65ab433ac`，分 3 段，每段 2 字节，显示结果为：`0006 5ab4 33ac`

4. 从高到底分段显示-只加 1 个前缀
   例子：`0x65ab433ac`，分 3 段，每段 2 字节，显示结果为：`0x0006 5ab4 33ac`

5. 从低到高分段显示-且转进制
   例子：`0x65ab433ac`，分 3 段，每段 2 字节，显示结果为：`13228 23220 6`

   很显然，这种显示方式是真的特别的恶心

### 二进制存储的分段显示

二进制存储的显示要比字符串存储的显示要难以理解得多

1. 大端序(字节序)

   例子：`0x294124cee09f86f6`，显示结果为：`0xce244129 0xf6869fe0`

   是不是面目全非了

## 大数各种表示形式之间的转换

todo
